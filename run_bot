import time
from strategy import prepare_indicators, strong_candle
from data import fetch_candles
from delta_client import DeltaClient
from state import BotState
from risk import dynamic_risk

client = DeltaClient()
state = BotState()

print("üöÄ FULL 1:1 BACKTEST ALIGNED BOT STARTED\n")

# --------------------- Logger Functions ---------------------
def log_candle(row, equity):
    msg = (
        f"\nüìä [{row['time']}] 15-min Candle Update\n"
        f"Open: {row['open']:.2f} | High: {row['high']:.2f} | Low: {row['low']:.2f} | Close: {row['close']:.2f} | Volume: {row['volume']:.2f}\n"
        f"Equity: {equity:.2f} | ATR%: {row['atr_percentile']:.2f} | EMA Slope: {row['ema_slope']:.2f}\n"
        "------------------------------------------------------------"
    )
    print(msg)

def log_entry(state, stop):
    msg = (
        f"\nüöÄ NEW POSITION OPENED\n"
        f"Side: {state.position.upper()}\n"
        f"Entry Price: {state.entry_price:.2f}\n"
        f"Size: {state.size:.4f}\n"
        f"Stop: {stop:.2f}\n"
        f"Risk per Unit: {state.entry_risk:.2f}\n"
        f"Capital: {state.capital:.2f}\n"
        "------------------------------------------------------------"
    )
    print(msg)

def log_exit(state, exit_price, pnl):
    msg = (
        f"\nüõë POSITION CLOSED\n"
        f"Side: {state.position.upper()}\n"
        f"Exit Price: {exit_price:.2f}\n"
        f"PnL: {pnl:.2f}\n"
        f"Equity After Trade: {state.capital:.2f}\n"
        "------------------------------------------------------------"
    )
    print(msg)

# --------------------- Bot Loop ---------------------
def run_bot():
    while True:
        try:
            # 1Ô∏è‚É£ Fetch latest candles
            df = fetch_candles("15m")
            df1h = fetch_candles("1h")
            df4h = fetch_candles("4h")

            df = prepare_indicators(df, df1h, df4h)

            row = df.iloc[-1]
            prev = df.iloc[-2]

            current_time = row["time"]
            if state.last_candle_time == current_time:
                time.sleep(60)
                continue
            state.last_candle_time = current_time

            # 2Ô∏è‚É£ Fetch balance once for equity tracking
            balance_data = client.get_balance()
            balances = balance_data.get("result", [])
            usdt_balance = next(
                (float(x["available_balance"]) for x in balances if x["asset_symbol"]=="USDT"), 0
            )
            state.initialize(usdt_balance)

            # 3Ô∏è‚É£ Calculate equity
            equity = state.capital
            if state.position == "long":
                equity += (row["close"] - state.entry_price) * state.size
            elif state.position == "short":
                equity += (state.entry_price - row["close"]) * state.size

            state.peak = max(state.peak, equity)
            current_dd = (state.peak - equity) / state.peak
            state.max_dd = max(state.max_dd, current_dd)

            # 4Ô∏è‚É£ Log candle info
            log_candle(row, equity)

            if state.cooldown > 0:
                state.cooldown -= 1
                time.sleep(60)
                continue

            # 5Ô∏è‚É£ Skip if not enough ATR or EMA slope
            if state.position is None:
                if row["atr_percentile"] < 0.70 or abs(row["ema_slope"]) <= row["close"]*0.001:
                    time.sleep(60)
                    continue

                # 6Ô∏è‚É£ Entry Signals
                long_signal = (
                    strong_candle(df, -2) and
                    strong_candle(df, -3) and
                    strong_candle(df, -4) and
                    row["close"] > row["ema200"] and
                    row["close"] > row["ema200_1h"] and
                    row["ema_slope"] > 0
                )

                short_signal = (
                    strong_candle(df, -2) and
                    strong_candle(df, -3) and
                    strong_candle(df, -4) and
                    row["close"] < row["ema200"] and
                    row["close"] < row["ema200_1h"] and
                    row["ema_slope"] < 0
                )

                if long_signal or short_signal:
                    risk_pct = dynamic_risk(current_dd, state.trades, row["atr_percentile"])
                    entry_price = row["close"]*(1+0.0005) if long_signal else row["close"]*(1-0.0005)
                    stop = prev["low"] - 0.2*row["atr"] if long_signal else prev["high"] + 0.2*row["atr"]
                    risk_per_unit = max(abs(entry_price-stop), row["atr"]*0.8)
                    risk_capital = state.capital * risk_pct
                    size = risk_capital / risk_per_unit

                    if size*entry_price > state.capital*3:  # LEVERAGE_CAP
                        size = (state.capital*3)/entry_price

                    state.position = "long" if long_signal else "short"
                    state.entry_price = entry_price
                    state.size = size
                    state.entry_risk = risk_per_unit

                    log_entry(state, stop)  # <-- Log entry

                    # Place order
                    client.place_market_order(
                        "BTCUSDT",
                        "buy" if long_signal else "sell",
                        size
                    )

            else:
                # 7Ô∏è‚É£ Exit Logic
                exit_price = None
                if state.position == "long":
                    stop = prev["low"] - 0.2*row["atr"]
                    if row["close"] < stop:
                        exit_price = stop
                if state.position == "short":
                    stop = prev["high"] + 0.2*row["atr"]
                    if row["close"] > stop:
                        exit_price = stop

                if exit_price:
                    pnl = (exit_price-state.entry_price)*state.size if state.position=="long" else (state.entry_price-exit_price)*state.size
                    fee = abs(state.size*state.entry_price)*0.0004 + abs(state.size*exit_price)*0.0004
                    pnl -= fee
                    state.capital += pnl
                    state.capital = max(state.capital, 0)
                    state.trades.append(pnl)

                    log_exit(state, exit_price, pnl)  # <-- Log exit

                    client.place_market_order(
                        "BTCUSDT",
                        "sell" if state.position=="long" else "buy",
                        state.size
                    )

                    state.position = None
                    state.cooldown = 6  # COOLDOWN_BARS

            time.sleep(60)

        except Exception as e:
            print("Bot Error:", e)
            time.sleep(30)
